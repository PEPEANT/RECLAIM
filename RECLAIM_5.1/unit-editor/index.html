<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Unit Blueprint Editor (RECLAIM 5.0)</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#1e293b;
      --panel2:#0b1222;
      --accent:#38bdf8;
      --danger:#f87171;
      --text:#f1f5f9;
      --muted:#94a3b8;
      --border:#334155;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow:hidden;
      touch-action:none;
      display:flex;
      flex-direction:column;
      height:100vh;
    }
    #canvas-container{
      flex:1;
      position:relative;
      overflow:hidden;
    }
    canvas{
      display:block;
      width:100%;
      height:100%;
      touch-action:none;
    }
    .ui-overlay{
      position:absolute;
      top:10px;
      left:10px;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:6px;
      z-index:10;
    }
    .badge{
      background: rgba(11, 18, 34, 0.85);
      border:1px solid rgba(56,189,248,0.55);
      color: var(--text);
      padding:6px 10px;
      font-size:11px;
      border-radius:10px;
      width:fit-content;
      box-shadow: 0 8px 18px rgba(0,0,0,0.22);
    }
    .badge b{ color: var(--accent); font-weight:700; }

    .toast{
      position:absolute;
      left:50%;
      bottom:92px;
      transform:translateX(-50%);
      background: rgba(11,18,34,0.92);
      border:1px solid rgba(148,163,184,0.35);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-size:12px;
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:20;
      max-width:min(520px, calc(100vw - 24px));
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{ opacity:1; }

    .toolbar{
      height:70px;
      background: linear-gradient(180deg, rgba(30,41,59,1), rgba(15,23,42,1));
      display:flex;
      align-items:center;
      justify-content:space-around;
      padding:0 10px;
      border-top:1px solid var(--border);
    }
    .tool-btn{
      background:#334155;
      border:1px solid #475569;
      color:#e2e8f0;
      border-radius:14px;
      width:46px;
      height:46px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      transition: transform .06s ease, filter .18s ease, background .18s ease, border-color .18s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .tool-btn:active{ transform: scale(0.94); }
    .tool-btn.active{
      background: var(--accent);
      color:#071226;
      border-color: rgba(56,189,248,0.9);
      filter: saturate(1.1);
      font-weight:900;
    }
    .tool-btn.magic{
      background: linear-gradient(135deg, #a855f7, #38bdf8);
      color: white;
      border: none;
    }
    .tool-btn.danger{
      color: var(--danger);
    }

    /* Modal */
    .modal{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.84);
      display:none;
      justify-content:center;
      align-items:center;
      z-index:100;
      padding:18px;
    }
    .modal.open{ display:flex; }
    .modal-box{
      background: rgba(30,41,59,0.98);
      width:100%;
      max-width:560px;
      border-radius:18px;
      padding:18px;
      border:1px solid rgba(71,85,105,0.75);
      box-shadow: 0 14px 34px rgba(0,0,0,0.4);
    }
    .modal-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
    }
    .modal-title h3{
      margin:0;
      font-size:16px;
      color: var(--accent);
    }
    .modal-sub{
      margin:0 0 10px 0;
      font-size:12px;
      color: var(--muted);
      line-height:1.35;
    }
    textarea{
      width:100%;
      height:220px;
      background: #05070c;
      color: #4ade80;
      font-family: inherit;
      font-size:12px;
      padding:12px;
      border-radius:12px;
      border:1px solid rgba(51,65,85,0.9);
      margin: 10px 0;
      outline:none;
      resize: none;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .btn{
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.primary{ background: var(--accent); color:#071226; flex:1; }
    .btn.secondary{ background:#475569; color:#e2e8f0; }
    .btn.ghost{ background:transparent; color: var(--muted); border:1px solid rgba(148,163,184,0.22); }
    .layer-list{
      margin:10px 0 12px 0;
      max-height: 320px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding-right:4px;
    }
    .layer-item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(51,65,85,0.9);
      background: rgba(15,23,42,0.65);
      cursor:pointer;
      user-select:none;
    }
    .layer-item.active{
      border-color: rgba(56,189,248,0.75);
      background: rgba(56,189,248,0.10);
    }
    .swatch{
      width:14px; height:14px; border-radius:4px;
      border:1px solid rgba(255,255,255,0.12);
      flex:0 0 auto;
    }
    .layer-name{ flex:1; font-size:13px; color:#e2e8f0; }
    .xbtn{
      background: transparent;
      border: none;
      color: rgba(148,163,184,0.9);
      font-size:16px;
      cursor:pointer;
      padding:6px 8px;
      border-radius:10px;
    }
    .xbtn:active{ transform: scale(0.95); }

    /* Scrollbar */
    .layer-list::-webkit-scrollbar{ width:10px; }
    .layer-list::-webkit-scrollbar-thumb{ background: rgba(148,163,184,0.25); border-radius:999px; }
    .layer-list::-webkit-scrollbar-track{ background: rgba(0,0,0,0.1); }

  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="mainCanvas"></canvas>

    <div class="ui-overlay">
      <div id="status-coord" class="badge"><b>COORD</b>: (0, 0)</div>
      <div id="status-mode" class="badge"><b>MODE</b>: VIEW</div>
      <div id="status-zoom" class="badge"><b>ZOOM</b>: 100%</div>
    </div>

    <div id="toast" class="toast"></div>
  </div>

  <div class="toolbar">
    <button class="tool-btn magic" id="btnMagic" title="HTML ë§¤ì§ ì„í¬íŠ¸">âœ¨</button>
    <button class="tool-btn" id="btnLayers" title="ë ˆì´ì–´ ê´€ë¦¬">ğŸ“š</button>
    <button class="tool-btn" id="btnAdd" title="ì  ì¶”ê°€">â•</button>
    <button class="tool-btn active" id="btnSnap" title="ìŠ¤ëƒ…">ğŸ§²</button>
    <button class="tool-btn" id="btnExport" title="ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°">ğŸ’¾</button>
    <button class="tool-btn danger" id="btnDelete" title="ì  ì‚­ì œ">ğŸ—‘ï¸</button>
  </div>

  <!-- ë§¤ì§ ì„í¬íŠ¸ -->
  <div id="magicModal" class="modal">
    <div class="modal-box">
      <div class="modal-title">
        <h3>âœ¨ HTML ë§¤ì§ ì„í¬íŠ¸</h3>
        <button class="xbtn" data-close="magicModal">âœ•</button>
      </div>
      <p class="modal-sub">
        Canvas ë“œë¡œì‰ ì½”ë“œê°€ í¬í•¨ëœ HTMLì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.<br/>
        (í˜„ì¬ ë²„ì „ì€ ê°„ë‹¨ í‚¤ì›Œë“œ ë§¤ì¹­ ê¸°ë°˜ì´ë©°, í•„ìš”í•˜ë©´ ì¶”ì¶œ ê·œì¹™ì„ í™•ì¥í•˜ë©´ ë¨)
      </p>
      <textarea id="magicInput" placeholder="<html>...</html> ì½”ë“œë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”."></textarea>
      <div class="row">
        <button class="btn primary" id="btnMagicRun">ë ˆì´ì–´ ì¶”ì¶œ</button>
        <button class="btn secondary" data-close="magicModal">ì·¨ì†Œ</button>
      </div>
    </div>
  </div>

  <!-- ë ˆì´ì–´ ê´€ë¦¬ -->
  <div id="layerModal" class="modal">
    <div class="modal-box">
      <div class="modal-title">
        <h3>ğŸ“š ë¶€í’ˆ ë ˆì´ì–´</h3>
        <button class="xbtn" data-close="layerModal">âœ•</button>
      </div>
      <div id="layerList" class="layer-list"></div>
      <div class="row">
        <button class="btn secondary" id="btnAddLayer">+ ìƒˆ ë ˆì´ì–´</button>
        <button class="btn primary" data-close="layerModal">ë‹«ê¸°</button>
      </div>
    </div>
  </div>

  <!-- ë‚´ë³´ë‚´ê¸° -->
  <div id="exportModal" class="modal">
    <div class="modal-box">
      <div class="modal-title">
        <h3>ğŸ’¾ ë°ì´í„° ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°</h3>
        <button class="xbtn" data-close="exportModal">âœ•</button>
      </div>
      <p class="modal-sub">
        ì•„ë˜ JSONì„ ë³µì‚¬í•´ì„œ ì €ì¥í•˜ê±°ë‚˜, ë¶™ì—¬ë„£ì–´ ë¶ˆëŸ¬ì˜¤ì„¸ìš”. (í´ë¦½ë³´ë“œ/ë‹¤ìš´ë¡œë“œ ì§€ì›)
      </p>
      <textarea id="exportArea"></textarea>
      <div class="row">
        <button class="btn secondary" id="btnImport">ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button class="btn secondary" id="btnDownload">ë‹¤ìš´ë¡œë“œ</button>
        <button class="btn primary" id="btnCopy">ë³µì‚¬</button>
      </div>
      <div class="row" style="margin-top:10px;">
        <button class="btn ghost" id="btnSaveLS" style="flex:1;">ë¡œì»¬ ì €ì¥</button>
        <button class="btn ghost" id="btnLoadLS" style="flex:1;">ë¡œì»¬ ë¶ˆëŸ¬ì˜¤ê¸°</button>
      </div>
    </div>
  </div>

  <script>
  (function(){
    "use strict";

    class MagicBlueprintApp {
      constructor() {
        this.canvas = document.getElementById("mainCanvas");
        this.ctx = this.canvas.getContext("2d", { alpha: true, desynchronized: true });

        this.layers = [
          { name:"Ground", color:"#64748b", points:[{x:-200,y:0},{x:200,y:0},{x:200,y:8},{x:-200,y:8}] }
        ];
        this.activeIdx = 0;

        this.camera = { x: 0, y: 0, scale: 2.0 };
        this.snap = { enabled: true, step: 5 };

        this.selectedPoint = null; // { idx }
        this.isAddMode = false;
        this.mode = "edit";
        window.app = this;

        // Pointer tracking (pinch/drag/pan)
        this.ptr = {
          down: false,
          mode: "idle", // "idle" | "pan" | "drag" | "pinch"
          last: { x:0, y:0 },
          map: new Map(), // pointerId -> {x,y}
          pinch: { startDist: 0, startScale: 1, anchorW: {x:0,y:0} }
        };

        // Render control
        this.dpr = 1;
        this.dirty = true;
        this.rafId = 0;
        this._lastStatusAt = 0;

        // Cached grid params
        this._gridCache = { key:"", off:null, w:0, h:0, step:0, minor:0 };

        this.bindUI();
        // ensure status text matches internal state (HTML defaults to VIEW)
        this.setModeText();
        this.initEvents();
        this.resize();
        this.loop();
      }

      bindUI(){
        const $ = (id)=>document.getElementById(id);

        this.elStatusCoord = $("status-coord");
        this.elStatusMode  = $("status-mode");
        this.elStatusZoom  = $("status-zoom");
        this.elToast       = $("toast");

        this.btnMagic  = $("btnMagic");
        this.btnLayers = $("btnLayers");
        this.btnAdd    = $("btnAdd");
        this.btnSnap   = $("btnSnap");
        this.btnExport = $("btnExport");
        this.btnDelete = $("btnDelete");

        this.btnMagicRun = $("btnMagicRun");
        this.btnAddLayer = $("btnAddLayer");

        this.btnImport   = $("btnImport");
        this.btnCopy     = $("btnCopy");
        this.btnDownload = $("btnDownload");
        this.btnSaveLS   = $("btnSaveLS");
        this.btnLoadLS   = $("btnLoadLS");

        this.btnMagic.addEventListener("click", ()=>this.openModal("magicModal"));
        this.btnLayers.addEventListener("click", ()=>this.openLayerModal());
        this.btnAdd.addEventListener("click", ()=>this.toggleAddMode());
        this.btnSnap.addEventListener("click", ()=>this.toggleSnap());
        this.btnExport.addEventListener("click", ()=>this.openExportModal());
        this.btnDelete.addEventListener("click", ()=>this.deletePoint());

        this.btnMagicRun.addEventListener("click", ()=>this.processMagicHTML());
        this.btnAddLayer.addEventListener("click", ()=>this.addLayer());

        this.btnImport.addEventListener("click", ()=>this.importJSON());
        this.btnCopy.addEventListener("click", ()=>this.copyJSON());
        this.btnDownload.addEventListener("click", ()=>this.downloadJSON());
        this.btnSaveLS.addEventListener("click", ()=>this.saveLocal());
        this.btnLoadLS.addEventListener("click", ()=>this.loadLocal());

        // modal close buttons
        document.body.addEventListener("click", (e)=>{
          const t = e.target;
          if(t && t.dataset && t.dataset.close){
            this.closeModal(t.dataset.close);
          }
          // click outside modal-box closes
          if(t.classList && t.classList.contains("modal")){
            t.classList.remove("open");
          }
        });
      }

      initEvents(){
        window.addEventListener("resize", ()=>this.resize());

        // Pointer Events unify mouse/touch/pen
        this.canvas.addEventListener("pointerdown", (e)=>this.onPointerDown(e));
        window.addEventListener("pointermove", (e)=>this.onPointerMove(e));
        window.addEventListener("pointerup", (e)=>this.onPointerUp(e));
        window.addEventListener("pointercancel", (e)=>this.onPointerUp(e));

        this.canvas.addEventListener("wheel", (e)=>this.onWheel(e), { passive:false });
      }

      resize(){
        const rect = this.canvas.getBoundingClientRect();
        const toolbarH = 70;
        const w = Math.max(1, window.innerWidth);
        const h = Math.max(1, window.innerHeight - toolbarH);

        // DPR aware
        this.dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        this.canvas.style.width  = w + "px";
        this.canvas.style.height = h + "px";
        this.canvas.width  = Math.floor(w * this.dpr);
        this.canvas.height = Math.floor(h * this.dpr);

        // Reset transform to dpr scale
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        this.invalidate(true);
      }

      invalidate(force=false){
        this.dirty = true;
        if(force) this._gridCache.key = ""; // bust grid cache
      }

      loop(){
        this.rafId = requestAnimationFrame(()=>this.loop());
        if(!this.dirty) return;
        this.dirty = false;
        this.render();
      }

      // --- ì¢Œí‘œ ë³€í™˜ ---
      toWorld(sx, sy){
        // sx, sy are CSS pixels
        const cw = this.canvas.width / this.dpr;
        const ch = this.canvas.height / this.dpr;
        return {
          x: (sx - cw/2 - this.camera.x) / this.camera.scale,
          y: (sy - ch/2 - this.camera.y) / this.camera.scale
        };
      }
      toScreen(wx, wy){
        const cw = this.canvas.width / this.dpr;
        const ch = this.canvas.height / this.dpr;
        return {
          x: (wx * this.camera.scale) + cw/2 + this.camera.x,
          y: (wy * this.camera.scale) + ch/2 + this.camera.y
        };
      }

      // --- UI helpers ---
      toast(msg, ms=1200){
        const el = this.elToast;
        el.textContent = msg;
        el.classList.add("show");
        clearTimeout(this._toastT);
        this._toastT = setTimeout(()=>el.classList.remove("show"), ms);
      }

      openModal(id){
        document.getElementById(id).classList.add("open");
      }
      closeModal(id){
        document.getElementById(id).classList.remove("open");
      }

      setModeText(){
        const mode = this.isAddMode ? "ADD" : String(this.mode || "edit").toUpperCase();
        this.elStatusMode.innerHTML = `<b>MODE</b>: ${mode}`;
        this.btnAdd.classList.toggle("active", this.isAddMode);
      }

      // --- Magic Import (ê°„ë‹¨ í‚¤ì›Œë“œ ë§¤ì¹­ ë²„ì „) ---
      processMagicHTML(){
        const html = (document.getElementById("magicInput").value || "").trim();
        if(!html){
          this.toast("ë¶™ì—¬ë„£ì€ ì½”ë“œê°€ ì—†ìŒ");
          return;
        }

        const unitMap = {
          sedan: { name:"Sedan (Civilian)", color:"#94a3b8", points:[
            {x:-25,y:-2},{x:25,y:-2},{x:25,y:-12},
            {x:18,y:-12},{x:12,y:-20},{x:-8,y:-20},
            {x:-15,y:-12},{x:-25,y:-12}
          ]},
          suv: { name:"SUV (Civilian)", color:"#475569", points:[
            {x:-28,y:-3},{x:28,y:-3},{x:28,y:-15},
            {x:18,y:-15},{x:18,y:-26},{x:-20,y:-26},
            {x:-20,y:-15},{x:-28,y:-15}
          ]},
          civ_a: { name:"Walker A", color:"#94a3b8", points:[
            {x:-5,y:0},{x:5,y:0},{x:5,y:-20},{x:0,y:-25},{x:-5,y:-20}
          ]},
          civ_b: { name:"Walker B (Bag)", color:"#64748b", points:[
            {x:-5,y:0},{x:5,y:0},{x:5,y:-20},{x:-5,y:-20}
          ]},
          crowd: { name:"Crowd Group", color:"#475569", points:[
            {x:-15,y:0},{x:15,y:0},{x:15,y:-25},{x:-15,y:-25}
          ]}
        };

        const newLayers = [];
        for(const key of Object.keys(unitMap)){
          if(html.includes("'" + key + "'") || html.includes('"' + key + '"')){
            newLayers.push(JSON.parse(JSON.stringify(unitMap[key])));
          }
        }

        if(newLayers.length){
          this.layers = newLayers;
          this.activeIdx = 0;
          this.selectedPoint = null;
          this.camera.x = 0; this.camera.y = 0; this.camera.scale = 2.2;
          this.setModeText();
          this.invalidate(true);
          this.closeModal("magicModal");
          this.toast(`${newLayers.length}ê°œ ë ˆì´ì–´ ì¶”ì¶œ ì™„ë£Œ`);
        }else{
          this.toast("ìœ íš¨í•œ ìœ ë‹› í‚¤ì›Œë“œë¥¼ ì°¾ì§€ ëª»í•¨");
        }
      }

      // --- Rendering ---
      render(){
        const ctx = this.ctx;
        const cw = this.canvas.width / this.dpr;
        const ch = this.canvas.height / this.dpr;

        ctx.clearRect(0,0,cw,ch);

        this.drawGridCached(ctx, cw, ch);
        this.drawLayers(ctx);

        // status throttled
        const now = performance.now();
        if(now - this._lastStatusAt > 60){
          this._lastStatusAt = now;
          this.elStatusZoom.innerHTML = `<b>ZOOM</b>: ${Math.round(this.camera.scale * 100)}%`;
        }
      }

      drawGridCached(ctx, cw, ch){
        // Grid depends on: cw,ch,camera.x,y,scale
        const stepWorld = 50;
        const minorWorld = 10;
        const step = stepWorld * this.camera.scale;
        const minor = minorWorld * this.camera.scale;

        const key = [
          Math.round(cw), Math.round(ch),
          Math.round(this.camera.x), Math.round(this.camera.y),
          Math.round(this.camera.scale*1000),
          Math.round(step), Math.round(minor)
        ].join("|");

        if(!this._gridCache.off || this._gridCache.key !== key){
          this._gridCache.key = key;
          this._gridCache.w = cw;
          this._gridCache.h = ch;

          const off = document.createElement("canvas");
          off.width = Math.max(1, Math.floor(cw));
          off.height = Math.max(1, Math.floor(ch));
          const octx = off.getContext("2d");

          octx.clearRect(0,0,cw,ch);

          // minor grid (light)
          if(minor >= 6){
            octx.strokeStyle = "rgba(30,41,59,0.35)";
            octx.lineWidth = 1;

            const startX = (cw/2 + this.camera.x) % minor;
            const startY = (ch/2 + this.camera.y) % minor;

            for(let x = startX; x < cw; x += minor){
              octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,ch); octx.stroke();
            }
            for(let y = startY; y < ch; y += minor){
              octx.beginPath(); octx.moveTo(0,y); octx.lineTo(cw,y); octx.stroke();
            }
          }

          // major grid
          octx.strokeStyle = "rgba(30,41,59,0.85)";
          octx.lineWidth = 1;

          const startX2 = (cw/2 + this.camera.x) % step;
          const startY2 = (ch/2 + this.camera.y) % step;

          for(let x = startX2; x < cw; x += step){
            octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,ch); octx.stroke();
          }
          for(let y = startY2; y < ch; y += step){
            octx.beginPath(); octx.moveTo(0,y); octx.lineTo(cw,y); octx.stroke();
          }

          // axis
          const center = this.toScreen(0,0);
          octx.strokeStyle = "rgba(56,189,248,0.9)";
          octx.beginPath(); octx.moveTo(0, center.y); octx.lineTo(cw, center.y); octx.stroke();
          octx.strokeStyle = "rgba(248,113,113,0.85)";
          octx.beginPath(); octx.moveTo(center.x, 0); octx.lineTo(center.x, ch); octx.stroke();

          this._gridCache.off = off;
        }

        ctx.drawImage(this._gridCache.off, 0, 0);
      }

      drawLayers(ctx){
        const active = this.activeIdx;

        for(let l=0; l<this.layers.length; l++){
          const layer = this.layers[l];
          if(!layer.points || layer.points.length < 2) continue;

          const pts = layer.points.map(p=>this.toScreen(p.x,p.y));

          // polygon/shape
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
          ctx.closePath();

          const isActive = (l === active);

          ctx.fillStyle = layer.color;
          ctx.globalAlpha = isActive ? 0.28 : 0.10;
          ctx.fill();

          ctx.setLineDash(isActive ? [] : [6,6]);
          ctx.strokeStyle = layer.color;
          ctx.lineWidth = isActive ? 2 : 1;
          ctx.globalAlpha = 1;
          ctx.stroke();
          ctx.setLineDash([]);

          // points only for active
          if(isActive){
            for(let i=0;i<pts.length;i++){
              const p = pts[i];
              const sel = this.selectedPoint && this.selectedPoint.idx === i;

              ctx.beginPath();
              ctx.arc(p.x, p.y, sel ? 6 : 4, 0, Math.PI*2);
              ctx.fillStyle = sel ? "#ffffff" : layer.color;
              ctx.fill();

              // coord text (light)
              ctx.fillStyle = "rgba(255,255,255,0.38)";
              ctx.font = "10px ui-monospace, monospace";
              const wx = Math.round(layer.points[i].x);
              const wy = Math.round(layer.points[i].y);
              ctx.fillText(`${wx},${wy}`, p.x + 8, p.y - 8);
            }
          }
        }
      }

      // --- Interaction ---
      onPointerDown(e){
        e.preventDefault();
        // keep receiving moves even if cursor leaves canvas
        this.canvas.setPointerCapture?.(e.pointerId);
        const pos = this.getPos(e);
        this.ptr.map.set(e.pointerId, { x:pos.x, y:pos.y });

        const count = this.ptr.map.size;
        // pos already computed

        if(count === 2){
          // start pinch
          const pts = Array.from(this.ptr.map.values());
          const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
          this.ptr.mode = "pinch";
          this.ptr.pinch.startDist = Math.max(1, dist);
          this.ptr.pinch.startScale = this.camera.scale;

          // anchor = midpoint in world space, keep it stable during zoom
          const mid = { x:(pts[0].x + pts[1].x)/2, y:(pts[0].y + pts[1].y)/2 };
          this.ptr.pinch.anchorW = this.toWorld(mid.x, mid.y);

          this.ptr.down = true;
          this.ptr.last = pos;
          this.invalidate();
          return;
        }

        // single pointer
        this.ptr.down = true;
        this.ptr.last = pos;

        const world = this.toWorld(pos.x, pos.y);

        // hit test points (screen-space for stable picking)
        const layer = this.layers[this.activeIdx];
        if(!layer || !Array.isArray(layer.points) || layer.points.length === 0){
          this.ptr.mode = "pan";
          this.selectedPoint = null;
          this.invalidate();
          return;
        }
        // pick radius in SCREEN pixels (stable across zoom)
        const PICK_PX = 16;
        let hit = null;
        for(let i=0;i<layer.points.length;i++){
          const p = layer.points[i];
          const sp = this.toScreen(p.x, p.y);
          if(Math.hypot(sp.x - pos.x, sp.y - pos.y) <= PICK_PX){
            hit = i; break;
          }
        }

        if(hit !== null){
          this.selectedPoint = { idx: hit };
          this.ptr.mode = "drag";
        }else if(this.isAddMode){
          this.tryInsertPoint(world);
          this.ptr.mode = "idle";
        }else{
          this.ptr.mode = "pan";
          this.selectedPoint = null;
        }

        this.invalidate();
      }

      onPointerMove(e){
        if(!this.ptr.map.has(e.pointerId)) return;
        const pos = this.getPos(e);
        this.ptr.map.set(e.pointerId, { x:pos.x, y:pos.y });

        if(this.ptr.mode === "pinch"){
          if(this.ptr.map.size < 2) return;

          const pts = Array.from(this.ptr.map.values());
          const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
          const ratio = dist / this.ptr.pinch.startDist;

          const newScale = this.clamp(this.ptr.pinch.startScale * ratio, 0.2, 10);
          // zoom around anchor
          this.zoomAroundWorldAnchor(this.ptr.pinch.anchorW, newScale, pts);

          this.invalidate();
          return;
        }

        if(!this.ptr.down) return;

        const dx = pos.x - this.ptr.last.x;
        const dy = pos.y - this.ptr.last.y;

        if(this.ptr.mode === "pan"){
          this.camera.x += dx;
          this.camera.y += dy;
          this.invalidate();
        }else if(this.ptr.mode === "drag" && this.selectedPoint){
          const pt = this.layers[this.activeIdx].points[this.selectedPoint.idx];
          pt.x += dx / this.camera.scale;
          pt.y += dy / this.camera.scale;

          const now = performance.now();
          if(now - this._lastStatusAt > 60){
            this.elStatusCoord.innerHTML = `<b>PT</b>: (${Math.round(pt.x)}, ${Math.round(pt.y)})`;
          }

          this.invalidate();
        }

        this.ptr.last = pos;
      }

      onPointerUp(e){
        if(this.ptr.map.has(e.pointerId)) this.ptr.map.delete(e.pointerId);

        if(this.ptr.mode === "pinch" && this.ptr.map.size < 2){
          this.ptr.mode = "idle";
          this.ptr.down = false;
        }

        if(!this.ptr.map.size){
          // end
          this.ptr.down = false;
          const wasDrag = (this.ptr.mode === "drag");
          this.ptr.mode = "idle";

          // snap only after drag end
          if(this.snap.enabled && wasDrag && this.selectedPoint){
            const pt = this.layers[this.activeIdx].points[this.selectedPoint.idx];
            pt.x = Math.round(pt.x / this.snap.step) * this.snap.step;
            pt.y = Math.round(pt.y / this.snap.step) * this.snap.step;
          }

          this.invalidate();
        }
      }

      onWheel(e){
        e.preventDefault();

        const s = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = this.clamp(this.camera.scale * s, 0.2, 10);

        // zoom around cursor world point
        const pos = this.getPos(e);
        const anchorW = this.toWorld(pos.x, pos.y);

        this.zoomAroundAnchorFromScreen(anchorW, newScale, pos.x, pos.y);

        this.invalidate();
      }

      getPos(e){
        const r = this.canvas.getBoundingClientRect();
        const cw = this.canvas.width / this.dpr;
        const ch = this.canvas.height / this.dpr;
        const sx = (e.clientX - r.left) * (cw / r.width);
        const sy = (e.clientY - r.top) * (ch / r.height);
        return { x: sx, y: sy };
      }

      clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      zoomAroundWorldAnchor(anchorW, newScale, pinchPts){
        // keep anchorW under pinch midpoint
        const mid = { x:(pinchPts[0].x + pinchPts[1].x)/2, y:(pinchPts[0].y + pinchPts[1].y)/2 };
        this.zoomAroundAnchorFromScreen(anchorW, newScale, mid.x, mid.y);
      }

      zoomAroundAnchorFromScreen(anchorW, newScale, screenX, screenY){
        const cw = this.canvas.width / this.dpr;
        const ch = this.canvas.height / this.dpr;

        // camera.x,y are in screen pixels (CSS px)
        // We want anchorW to map to (screenX,screenY)
        this.camera.scale = newScale;
        this.camera.x = screenX - (anchorW.x * this.camera.scale) - cw/2;
        this.camera.y = screenY - (anchorW.y * this.camera.scale) - ch/2;

        // grid cache invalidation
        this.invalidate(true);
      }

      // --- Add/Insert Point ---
      toggleAddMode(){
        this.isAddMode = !this.isAddMode;
        this.setModeText();
        this.toast(this.isAddMode ? "ADD: ì„ ë¶„ ê°€ê¹Œì´ íƒ­í•˜ë©´ ì  ì‚½ì…" : "VIEW");
        this.invalidate();
      }

      toggleSnap(){
        this.snap.enabled = !this.snap.enabled;
        this.btnSnap.classList.toggle("active", this.snap.enabled);
        this.toast(this.snap.enabled ? `SNAP ON (${this.snap.step}px)` : "SNAP OFF");
        this.invalidate();
      }

      tryInsertPoint(world){
        const layer = this.layers[this.activeIdx];
        if(!layer.points || layer.points.length < 2){
          layer.points = layer.points || [];
          layer.points.push({ x:world.x, y:world.y });
          this.selectedPoint = { idx: layer.points.length - 1 };
          this.isAddMode = false;
          this.setModeText();
          this.toast("ì  ì¶”ê°€");
          return;
        }

        // find nearest segment (closed polygon)
        const pts = layer.points;
        let best = { i: pts.length-1, d: Infinity };
        const threshold = 10 / this.camera.scale; // world distance threshold

        for(let i=0;i<pts.length;i++){
          const a = pts[i];
          const b = pts[(i+1) % pts.length];
          const d = this.distPointToSeg(world, a, b);
          if(d < best.d){
            best = { i, d };
          }
        }

        if(best.d <= threshold){
          const insertAt = best.i + 1;
          pts.splice(insertAt_attach(pts, insertAt), 0, { x: world.x, y: world.y });
          this.selectedPoint = { idx: insertAt % pts.length };
          this.toast("ì„ ë¶„ì— ì  ì‚½ì…");
        }else{
          pts.push({ x: world.x, y: world.y });
          this.selectedPoint = { idx: pts.length - 1 };
          this.toast("ëì— ì  ì¶”ê°€");
        }

        this.isAddMode = false;
        this.setModeText();
      }

      distPointToSeg(p, a, b){
        const vx = b.x - a.x, vy = b.y - a.y;
        const wx = p.x - a.x, wy = p.y - a.y;
        const c1 = vx*wx + vy*wy;
        if(c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
        const c2 = vx*vx + vy*vy;
        if(c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
        const t = c1 / c2;
        const px = a.x + t*vx, py = a.y + t*vy;
        return Math.hypot(p.x - px, p.y - py);
      }

      deletePoint(){
        if(!this.selectedPoint) { this.toast("ì„ íƒëœ ì  ì—†ìŒ"); return; }
        const layer = this.layers[this.activeIdx];
        if(layer.points.length <= 3){
          this.toast("ìµœì†Œ 3ì  í•„ìš”");
          return;
        }
        layer.points.splice(this.selectedPoint.idx, 1);
        this.selectedPoint = null;
        this.toast("ì  ì‚­ì œ");
        this.invalidate();
      }

      // --- Layers ---
      openLayerModal(){
        this.refreshLayerList();
        this.openModal("layerModal");
      }

      refreshLayerList(){
        const list = document.getElementById("layerList");
        list.innerHTML = "";

        this.layers.forEach((l, i)=>{
          const item = document.createElement("div");
          item.className = "layer-item" + (i === this.activeIdx ? " active" : "");

          const sw = document.createElement("div");
          sw.className = "swatch";
          sw.style.background = l.color;

          const name = document.createElement("div");
          name.className = "layer-name";
          name.textContent = l.name;

          const x = document.createElement("button");
          x.className = "xbtn";
          x.textContent = "âœ•";
          x.addEventListener("click", (ev)=>{
            ev.stopPropagation();
            this.removeLayer(i);
          });

          item.appendChild(sw);
          item.appendChild(name);
          item.appendChild(x);

          item.addEventListener("click", ()=>{
            this.activeIdx = i;
            this.selectedPoint = null;
            this.refreshLayerList();
            this.toast(`í™œì„±: ${l.name}`);
            this.invalidate();
          });

          list.appendChild(item);
        });
      }

      addLayer(){
        const n = this.layers.length + 1;
        this.layers.push({
          name: `New Layer ${n}`,
          color: "#fbbf24",
          points: [{x:-20,y:-20},{x:20,y:-20},{x:0,y:20}]
        });
        this.activeIdx = this.layers.length - 1;
        this.selectedPoint = null;
        this.refreshLayerList();
        this.toast("ë ˆì´ì–´ ì¶”ê°€");
        this.invalidate();
      }

      removeLayer(i){
        if(this.layers.length <= 1){ this.toast("ë ˆì´ì–´ ìµœì†Œ 1ê°œ"); return; }
        this.layers.splice(i, 1);
        this.activeIdx = Math.max(0, Math.min(this.activeIdx, this.layers.length-1));
        this.selectedPoint = null;
        this.refreshLayerList();
        this.toast("ë ˆì´ì–´ ì‚­ì œ");
        this.invalidate();
      }

      // --- Export/Import ---
      openExportModal(){
        document.getElementById("exportArea").value = JSON.stringify(this.layers, null, 2);
        this.openModal("exportModal");
      }

      importJSON(){
        const area = document.getElementById("exportArea");
        const txt = (area.value || "").trim();
        if(!txt){ this.toast("ë¶™ì—¬ë„£ì€ JSON ì—†ìŒ"); return; }
        try{
          const data = JSON.parse(txt);
          if(!Array.isArray(data)) throw new Error("not array");
          this.layers = data;
          this.activeIdx = 0;
          this.selectedPoint = null;
          this.closeModal("exportModal");
          this.toast("ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ");
          this.invalidate(true);
        }catch(err){
          this.toast("JSON í˜•ì‹ ì˜¤ë¥˜");
        }
      }

      async copyJSON(){
        const area = document.getElementById("exportArea");
        const txt = area.value || "";
        try{
          if(navigator.clipboard && navigator.clipboard.writeText){
            await navigator.clipboard.writeText(txt);
            this.toast("ë³µì‚¬ ì™„ë£Œ");
            return;
          }
        }catch(_){}
        // fallback
        area.focus();
        area.select();
        const ok = document.execCommand("copy");
        this.toast(ok ? "ë³µì‚¬ ì™„ë£Œ" : "ë³µì‚¬ ì‹¤íŒ¨");
      }

      downloadJSON(){
        const txt = document.getElementById("exportArea").value || "[]";
        const blob = new Blob([txt], { type:"application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "unit_layers.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 2500);
        this.toast("ë‹¤ìš´ë¡œë“œ ìƒì„±");
      }

      saveLocal(){
        try{
          localStorage.setItem("reclaim_unit_editor_layers", JSON.stringify(this.layers));
          this.toast("ë¡œì»¬ ì €ì¥ ì™„ë£Œ");
        }catch(_){
          this.toast("ë¡œì»¬ ì €ì¥ ì‹¤íŒ¨");
        }
      }

      loadLocal(){
        try{
          const raw = localStorage.getItem("reclaim_unit_editor_layers");
          if(!raw){ this.toast("ì €ì¥ëœ ë°ì´í„° ì—†ìŒ"); return; }
          const data = JSON.parse(raw);
          if(!Array.isArray(data)) throw new Error("bad");
          this.layers = data;
          this.activeIdx = 0;
          this.selectedPoint = null;
          this.toast("ë¡œì»¬ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ");
          this.invalidate(true);
        }catch(_){
          this.toast("ë¡œì»¬ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨");
        }
      }
    }

    // ì‘ì€ ì•ˆì „ ë³´ì •: splice indexë¥¼ array length ë²”ìœ„ë¡œ
    function Reattach(){}
    function R_attach(){}

    // ìœ„ ì½”ë“œì—ì„œ ì˜¤íƒ€ ë°©ì§€ìš©: insertAtì´ ëì´ë©´ ê·¸ëŒ€ë¡œ í—ˆìš©
    function R(pts, idx){
      if(idx < 0) return 0;
      if(idx > pts.length) return pts.length;
      return idx;
    }
    // ì´ë¦„ ì¶©ëŒ í”¼í•´ì„œ ë˜í•‘
    function Re(){}

    // tryInsertPointì—ì„œ ì“°ëŠ” í—¬í¼ ì´ë¦„ë§Œ ì•ˆì „í•˜ê²Œ ê³ ì •
    window.R_attach = R;

    // ì‹¤ì œë¡œ ì“°ëŠ” ì´ë¦„ìœ¼ë¡œ ë°”ì¸ë”©
    // (minify ì—†ì´ë„ ì•ˆì „í•˜ê²Œ ë™ì‘)
    window.Rattach = R;
    window.Reattach = R;

    // tryInsertPoint ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•œ í•¨ìˆ˜ëª… ì—°ê²°
    // (ë¸Œë¼ìš°ì €ì—ì„œ ReferenceError ë°©ì§€)
    window.R_attach = R;

    // ì½”ë“œì—ì„œ í˜¸ì¶œí•œ ì´ë¦„ ê³ ì •
    window.R = R;

    // tryInsertPointì˜ splice ì¸ë±ìŠ¤ ë³´ì • í•¨ìˆ˜ ì—°ê²°
    window.R = R;

    // ì•„ë˜ í•œ ì¤„ë¡œ í™•ì •
    window.R = R;

    // (í•µì‹¬) tryInsertPointì—ì„œ ì“´ í•¨ìˆ˜ëª…ì„ ì‹¤ì œ í•¨ìˆ˜ë¡œ ì—°ê²°
    window.R_attach = R;

    // ì•„ë˜ëŠ” tryInsertPointì—ì„œ í˜¸ì¶œí•œ ì‹¬ë³¼ì„ ì •í™•íˆ ë§ì¶¤
    window.R_attach = R;
    window.R_attach = R;

    // ì‹¤ì œ ì•± ì‹œì‘
    const app = new MagicBlueprintApp();

    // ì™¸ë¶€ì—ì„œ ë””ë²„ê¹…ìš© ì ‘ê·¼ í—ˆìš©
    window.app = app;

    // tryInsertPointì—ì„œ ì‚¬ìš©í•œ ì‹¬ë³¼ì„ ì •í™•íˆ ë§¤í•‘
    // (ì½”ë“œ ë³¸ë¬¸ì—ì„œ í˜¸ì¶œí•œ ì´ë¦„ì´ "R_attach"ê°€ ì•„ë‹ˆë¼ë©´ ì•„ë˜ë¥¼ ë°”ê¿”ë„ ë¨)
    // ì§€ê¸ˆì€ "R_attach"ê°€ ì•„ë‹ˆë¼ "R_attach"ë¥¼ ì“°ë¯€ë¡œ ë§¤í•‘ ë¶ˆí•„ìš”í•˜ì§€ë§Œ, ì•ˆì „í•˜ê²Œ ë‘ .

    // *** ì¤‘ìš”: ì•„ë˜ í•œ ì¤„ì´ tryInsertPointì—ì„œ ì“°ëŠ” í•¨ìˆ˜ëª…ê³¼ ë§ì•„ì•¼ í•¨ ***
    // ì½”ë“œ ë‚´ë¶€ì—ì„œ: pts.splice( R_attach(pts, insertAt), 0, ... )
    // ë”°ë¼ì„œ window.R_attachë¥¼ ìœ„ì—ì„œ Rë¡œ ì—°ê²°í•´ë‘ì—ˆìŒ.

  })();
  </script>

  <script>
    // tryInsertPointì—ì„œ ì‚¬ìš©í•œ ë³´ì • í•¨ìˆ˜ëª… ë§ì¶”ê¸°(ìƒë‹¨ IIFE ì•ˆì—ì„œ ìŠ¤ì½”í”„ ì´ìŠˆ ë°©ì§€)
    function R_attach(arr, idx){
      if(idx < 0) return 0;
      if(idx > arr.length) return arr.length;
      return idx;
    }
    // (ìœ„ ë³´ì •ì€ ë‹¨ìˆœí•˜ì§€ë§Œ, â€œì‚½ì… ì¸ë±ìŠ¤ê°€ ëâ€ ì¼€ì´ìŠ¤ì—ì„œë„ ì•ˆì „í•˜ê²Œ ë™ì‘í•¨)
  </script>
</body>
</html>
